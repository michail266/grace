import java.util.List;
import java.util.LinkedList;

import gr.hua.dit.compiler.types.*;
import gr.hua.dit.compiler.errors.*;
import gr.hua.dit.compiler.ast.*;
import gr.hua.dit.compiler.Symbol.*;

parser Parser;
symbol Symbols;

parser code{:
       Map<String,Integer> mem = new HashMap<String,Integer>();
       Map<String,String> mems = new HashMap<String,String>();
:}

terminal T_plus, T_times, T_lpar, T_rpar,  T_if, T_then, T_else, T_assign,T_let, T_print, T_prints, T_coma, T_minus, T_while, T_dot, T_colon, T_semicolon, T_Smaller, T_Bigger, T_OpBr, T_ClBr, T_OpCuBr, T_ClCuBr, T_Insert, T_SmEQ, T_BigEq, T_do, T_or, T_and, T_div, T_fun, T_mod, T_not, T_ref, T_var, T_return, T_nothing, T_DoQu ,T_SiQu;
terminal Integer T_num;
terminal String T_id ;

non terminal Statement stmt, if_expr, while_expr;
non terminal Expr expr, bool_expr;
non terminal String strings, string, char;
non terminal java.util.List<Decl> decl_list;
non terminal Program program;


precedence left T_plus , T_minus;
precedence left T_times , T_div;
precedence left T_else , T_do;

 stmt:s                                  {: RESULT = new LinkedList<Statement>(); RESULT.add(s); :}
        ;

stmt ::= | T_let T_id:id T_assign expr:e                 {: RESULT = new Let(id, e); :}
         | T_id T_assign strings   
         | T_return expr:e                         {: System.out.println(e); :}
         | T_prints string
         | T_print expr:e                          {:RESULT = new PrintStatement(e);:} 
         | T_if expr:c T_then stmt:t T_else stmt:e  {: RESULT = new IfStatement(c,t,e); :}       
         | if_expr 
         | while_expr
         ;



while_expr ::=T_while expr:cond T_do stmt_list            
       ;

expr ::= expr:e1 T_plus expr:e2      {: RESULT = new BinOp(BinOp.Operator.Plus, e1,re); :}
       | expr:e1 T_times expr:e2     {:  RESULT = new BinOp(BinOp.Operator.Times, e1,re); :}
       | expr:e1 T_div expr:re        {: RESULT = new BinOp(BinOp.Operator.Div, e1,re); :}
       | T_num:n                     {: RESULT = new NumConst(num); :}
       | T_id:v                      {: RESULT = new Id(id);  :}
       | T_lpar expr:e1 T_rpar       {: RESULT = e1; :}
       ;

type ::= T_int                            {:RESULT = BasicType.Int; :}
       | T_char                           {:RESULT = BasicType.Char :}
       ;