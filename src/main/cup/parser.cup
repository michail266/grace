import java.util.List;
import java.util.LinkedList;
import java.util.Collections;
import gr.hua.dit.compiler.types.*;
import gr.hua.dit.compiler.errors.*;
import gr.hua.dit.compiler.ast.*;
import gr.hua.dit.compiler.Symbol.*;

terminal T_plus, T_times, T_lpar, T_rpar,  T_if, T_then, T_else, T_int, T_char ;
terminal T_assign,T_let, T_print, T_prints, T_coma ;
terminal T_minus, T_while, T_dot, T_colon, T_semicolon, T_Smaller, T_Bigger, T_OpBr;
terminal T_ClBr, T_OpCuBr, T_ClCuBr, T_Insert, T_SmEQ, T_BigEq, T_do, T_or, T_and, T_div ;
terminal T_fun, T_mod, T_not, T_ref, T_var, T_return, T_nothing, T_DoQu ,T_SiQu;
terminal Integer T_num;
terminal java.lang.String T_id;


non terminal java.util.List<Stmt> stmt_list;
non terminal java.util.List<String> id_list;
non terminal Stmt stmt, if_expr, while_expr;
non terminal Decl decl;
non terminal Expr expr, bool_expr;
non terminal String strings, string, char;
non terminal java.util.List<Decl> decl_list;
non terminal Program program;
non terminal Type type, ret_type;
non terminal Stmt fun_def;
non terminal Stmt header;
non terminal java.util.List<Stmt> local_def_list;
non terminal Stmt fpar_def;
non terminal java.util.List<Stmt> fpar_def_list;

precedence left T_plus , T_minus;
precedence left T_times , T_div;
precedence left T_else , T_do;

start with program;

program ::= fun_def:fd             {: RESULT = new Program(Collections.singletonList(fd)); :}
      ;

fun_def ::= header:h local_def_list:ldl T_OpCuBr stmt_list:sl T_ClCuBr   {: RESULT = new Block(new LinkedList<Decl>(), sl); :}
      ;


header ::= T_fun T_id:id T_lpar fpar_def_list:fpl T_rpar T_colon ret_type:rt  {: RESULT = new Block(new LinkedList<Decl>(), new LinkedList<Stmt>()); :}
       | T_fun T_id:id T_lpar T_rpar T_colon ret_type:rt                     {: RESULT = new Block(new LinkedList<Decl>(), new LinkedList<Stmt>()); :}
       ;


fpar_def ::= T_ref id_list:il1 T_coma id_list:il2 T_colon type:t  {: RESULT = new Block(new LinkedList<Decl>(), new LinkedList<Stmt>()); :}
       ;


fpar_def_list ::= fpar_def:fd                         {: RESULT = new LinkedList<Stmt>(); ((LinkedList<Stmt>)RESULT).add(fd); :}
           | fpar_def_list:fdl T_semicolon fpar_def:fd {: fdl.add(fd); RESULT = fdl; :}
           ;

local_def_list ::=                                     {: RESULT = new LinkedList<Stmt>(); :}
           | local_def_list:ldl fun_def:fd             {: ldl.add(fd); RESULT = ldl; :}
           | local_def_list:ldl header:h T_semicolon   {: ldl.add(h); RESULT = ldl; :}
           ;




decl_list ::=                                     {: RESULT = new LinkedList<Decl>(); :}
           | decl_list:dl decl:d                  {: dl.add(d); RESULT = dl; :}
           ;




decl ::= T_var T_id:id T_colon type:t  T_semicolon            {: RESULT = new Decl(id,t); :}
      ;

stmt_list ::=                                      {: RESULT = new LinkedList<Stmt>(); :}      
        |  stmt_list:sl stmt:s                     {: sl.add(s); RESULT = sl; :}
        ;
       



stmt ::= T_var T_id:id T_Insert expr:e  T_semicolon               {: RESULT = new Let(id, e); :}
         | T_id:id T_assign strings:s T_semicolon                  {: RESULT = new Block(new LinkedList<Decl>(), new LinkedList<Stmt>()); :}
         | T_return expr:e T_semicolon                             {: System.out.println(e); RESULT = new Block(new LinkedList<Decl>(), new LinkedList<Stmt>()); :}
         | T_prints string:s T_semicolon                           {: RESULT = new Block(new LinkedList<Decl>(), new LinkedList<Stmt>()); :}
         | T_print expr:e T_semicolon                              {: RESULT = new Print(e); :}
         | T_if expr:e T_then stmt:ts T_else stmt:es               {: RESULT = new If(e,ts,es); :}
         | T_if expr:e T_then stmt:ts                              {: RESULT = new If(e,ts); :}
         | while_expr:we                                           {: RESULT = we; :}
         ;

id_list ::=                                {: RESULT = new LinkedList<String>(); :}
         | id_list:ids T_id:id             {: ids.add(id); RESULT = ids; :}
         ;



while_expr ::= T_while expr:cond T_do stmt_list:sl    {: RESULT = new Block(new LinkedList<Decl>(), sl); :}
       ;

expr ::= expr:e1 T_plus expr:e2      {: RESULT = new BinOp(BinOp.Operator.Plus, e1,e2); :}
       | expr:e1 T_times expr:e2     {:  RESULT = new BinOp(BinOp.Operator.Times, e1,e2); :}
       | expr:e1 T_div expr:re        {: RESULT = new BinOp(BinOp.Operator.Div, e1,re); :}
       | T_num:n                     {: RESULT = new NumConst(n); :}
       | T_id:id                      {: RESULT = new Id(id); :}
       | T_lpar expr:e1 T_rpar       {: RESULT = e1; :}
       ;

type ::= T_int                            {:RESULT = BasicType.Int; :}
       | T_char                           {:RESULT = BasicType.Char; :}
       ;

ret_type ::= type:t                               {: RESULT = t; :}
       | T_nothing                                {: RESULT = BasicType.Int; :}
       ;


strings ::= T_SiQu char:c T_SiQu                  {: RESULT = c; :}
       | T_DoQu string:s T_DoQu                   {: RESULT = s; :}
       ;

char ::= T_id:id                              {: RESULT = id; :}
       ;
       
string ::= T_id:id                            {: RESULT = id; :}
       ;
